% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/05_people-like-thee.R
\name{people_like_thee}
\alias{people_like_thee}
\title{People-Like-Me for Dynamic Prediction}
\usage{
people_like_thee(train_data, test_data, new_data, outcome_var, time_var, id_var, ...)
}
\arguments{
\item{train_data}{\code{data.frame}. The training dataset.}

\item{test_data}{\code{data.frame}. The testing dataset.}

\item{new_data}{\code{data.frame}. A new dataset for prediction.}

\item{outcome_var}{\code{character}. The name of the outcome variable in the dataset.}

\item{time_var}{\code{character}. The name of the time variable in the dataset.}

\item{id_var}{\code{character}. The name of the ID variable in the dataset.}

\item{tmin}{\code{numeric}. The minimum time point for prediction.}

\item{tmax}{\code{numeric}. The maximum time point for prediction.}

\item{anchor_time}{\code{numeric vector}. The anchor time point for the prediction.}

\item{gamlss_formula}{\code{formula or text}. The formula for the GAMLSS model's mean function.}

\item{gamlss_sigma}{\code{formula or text}. The formula for the GAMLSS model's sigma function.}

\item{match_methods}{\code{character}. The distance metric used for matching (e.g., \code{"euclidean"} or \code{"mahalanobis"}).}

\item{weight}{\code{logical}. Whether to include the weights for the GAMLSS model.}

\item{match_alpha}{\code{numeric}. Alpha level for matching (e.g., \code{0.05}).}

\item{match_number}{\code{integer}. The number of matches to include for each individual.}

\item{match_plot}{\code{logical}. If \code{TRUE}, a plot of the matching process will be generated.}

\item{predict_plot}{\code{logical}. If \code{TRUE}, a plot of the predicted and observed values will be generated.}

\item{...}{Additional arguments passed to other methods.}

\item{brokenstick_knots}{\code{numeric vector}. The knots for the brokenstick model.}
}
\value{
A list containing:
\describe{
\item{\code{centiles_observed}}{\code{numeric}. The observed centiles based on the testing dataset's observed values.}
\item{\code{centiles_predicted}}{\code{numeric}. The predicted centiles based on the testing dataset's predicted values.}
\item{\code{plot}}{\code{ggplot2 plot}. A plot showing both observed and predicted centiles, if \code{predict_plot = TRUE}.}
}
}
\description{
This function predicts outcomes for a testing dataset using a dynamic prediction method. It fits a brokenstick-like model using \code{lme4::lmer()} on the training dataset, which can include time-variant and -invariant variables, as well as interactions. The model is then applied to predict outcomes in the testing dataset at specified anchor times. A matching step using Euclidean or Mahalanobis distances for individuals is included. The final model is a weighted GAMLSS model with user-defined formulas for the mean and sigma functions. The function returns predicted values for the testing dataset, including observation times, predictive times, and predicted values.
}
\details{
The brokenstick-like model is based on \code{lme4::lmer()} and the dynamic prediction uses the \code{JMbayes2::IndvPred_lme()} method. Individual matching is based on distance measures, and predictions are made using a weighted GAMLSS model for each individual.
}
\note{
\describe{
\item{\code{matching_number} and \code{matching_alpha}}{Only one of these can be used for the Mahalanobis distance matching method.}
\item{Euclidean and \code{matching_number}}{Only \code{matching_number} can be used for the Euclidean distance matching method.}
}
}
\examples{
\dontrun{
# Example usage
result <- people_like_thee(
  train_data = train_data,
  test_data = test_data,
  new_data = new_data,
  outcome_var = "outcome",
  time_var = "time",
  id_var = "id",
  tmin = 0,
  tmax = 10,
  brokenstick_knots = c(1, 3, 5),
  anchor_time = 5,
  gamlss_formula = y ~ x,
  gamlss_sigma = ~ z,
  match_methods = "mahalanobis",
  weight = NULL,
  match_alpha = 0.95,
  # match_number = 5,  # only use one method
  match_plot = TRUE,
  predict_plot = TRUE
)

# Accessing results
print(result$centiles_observed)
print(result$centiles_predicted)
}
}
